\subsection{Оценка сложности генерации простого числа}
Будем решать задачу генерации простого числа заданной длины. Для этого выберем случайное
$n \xleftarrow{R} [2^{\log_2{n}}, 2^{\log_2{n} + 1} - 1]$. Также у нас есть некоторое фактор-множество
$F~=~\{x_i~|~x_i~\in~PRIMES\}$, которое состоит из последовательных малых простых чисел, исключая число 2.
Составим систему остатков $R_n~=~\{n_i~=~n~(mod~x_i)~|~x_i~\in~F\}$. Если среди них есть хотя бы один ноль, то
число $n$ делится на соответствующее малое простое, следовательно $n$ является составным. 
Заметим, что можно просто построить систему $R_{n+2}$, зная заранее $R_n$. Нужно просто к остаткам прибавить двойку и, если
нужно, привести по модулю. Таким образом можно просто построить любую другую систему вида $R_{n+k}$, причем имеет смысл $k$ выбирать всегда
четным, иначе $n + k$ получится четным, следовательно составным.
Метод состоит в том, чтобы строить $R_n$, и в случае того, если $R_n$ содержит ноль, то строить следующе $R_{n+2}$, и так далее, пока
не найдем такой $R_{n+2i}$, что он не содержит нуля, т.е. взаимно прост со всеми числами фактор-множества.
Недостаток метода в том, что при большой цепочке подряд идущих составных числах, может оказаться, что $i$ довольно велико, при этом необходимо на каждой
итерации заново пересчитывать все суммы.

В связи с этим предлагается следующая оптимизация этого метода. 
Рассмотрим конкретное число из факторной базы $p = 5$, и $n = 29$.
$n\mod p=29\mod 5=4$. Чтобы получить число, делящееся на $5$, к $29$ необходимо добавить минимальное четное число $6$, а потом добавлять
всегда по $10$. Таким образом после постройки $R_{n = 29}$ не нужно строить $R_{n+6}$, $R_{n+16}$, и т.д. 
Такие числа как $6, 16, 26, ... $ для $n = 29$ будем называть запрещенными.
Таким образом можно построить множество $D$, состоящее из запрещенных чисел для $n$ и всех чисел из факторной базы. Таким образом, если в множестве $D$ не
будет содержаться, например число $4$, то $R_{n+4}$ будет взаимно просто со всеми числами факторной базы.
При реализации этого метода ограничим число $i$ некоторым порогом (например максимальным числом из факторной базы + 1), 
чтобы иметь гарантированно константное использование памяти.
При этом необходимо предварительно посчитать $|F|$ раз остаток от деления $n$ на каждое простое число.
При составлении множества запрещенных чисел на каждой итерации будет добавляться примерно $\frac{|F|}{p_i}$ чисел.
Таким образом, генерация множества запрещенных чисел имеет асимптотику $$O(|F|\sum_{p \in F}{\frac{1}{p}}) = O(|F|\ln{\ln p_{max}}),$$ где $p_{max}$ - максимальное
число из факторной базы. Согласно теореме о распределении простых чисел
$$|F| \approx \frac{p_{max}}{\ln p_{max}}.$$ Следовательно генерация множества запрещенных чисел имеет асимптотику 
$$O(\frac{p_{max}\ln{\ln p_{max}}}{\ln p_{max}}).$$
Этап построения $R_n$ имеет асимптотику $O(|F|\log_2{n})$, так как выполняется $|F|$ операций приведения по малому модулю.
В итоге искомая асиптотика равна $$O(\frac{p_{max}(\ln{\ln p_{max}} + \log_2{n})}{\ln p_{max}}).$$
