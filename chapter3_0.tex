\chapter{Реализация}
\section{Результаты оптимизации генерации простых чисел}
Будем решать задачу генерации простого числа заданной длины. Для этого выберем случайное
$n \xleftarrow{R} [2^{\log_2{n}}, 2^{\log_2{n} + 1} - 1]$. Также у нас есть некоторое фактор-множество
$F~=~\{x_i~|~x_i~\in~PRIMES\}$, которое состоит из последовательных малых простых чисел, исключая число 2.
Составим систему остатков $R_n~=~\{n_i~=~n~(mod~x_i)~|~x_i~\in~F\}$. Если среди них есть хотя бы один ноль, то
число $n$ делится на соответствующее малое простое, следовательно $n$ является составным. 
Заметим, что можно просто построить систему $R_{n+2}$, зная заранее $R_n$. Нужно просто к остаткам прибавить двойку и, если
нужно, привести по модулю. Таким образом можно просто построить любую другую систему вида $R_{n+k}$, причем имеет смысл $k$ выбирать всегда
четным, иначе $n + k$ получится четным, следовательно составным.
Метод состоит в том, чтобы строить $R_n$, и в случае того, если $R_n$ содержит ноль, то строить следующе $R_{n+2}$, и так далее, пока
не найдем такой $R_{n+2i}$, что он не содержит нуля, т.е. взаимно прост со всеми числами фактор-множества.
Недостаток метода в том, что при большой цепочке подряд идущих составных числах, может оказаться, что $i довольно велико$, при этом необходимо на каждой
итерации заново пересчитывать все суммы.

В связи с этим придумана оптимизация этого метода. 
Рассмотрим конкретное число из факторной базы $p = 5$, и $n = 29$.
$n \mod p = 29 \mod 5 = 4$. Чтобы получить число, делящееся на $5$, к $29$ необходимо добавить минимальное четное число $6$, а потом добавлять
всегда по $10$. Таким образом после постройки $R_{n = 29}$ не нужно строить $R_{n+6}$, $R_{n+16}$, и т.д. 
Такие числа как $6, 16, 26, ... $ для $n = 29$ будем называть запрещенными.
Таким образом можно построить множество $D$, состоящее из запрещенных чисел для $n$ и всех чисел из факторной базы. Таким образом, если в множестве $D$ не
будет содержаться, например число $4$, то $R_{n+4}$ будет взаимно просто со всеми числами факторной базы.
При реализации этого метода ограничим число $i$ некоторым порогом (например максимальным числом из факторной базы + 1), 
чтобы иметь гарантированно константное использование памяти.
При этом необходимо предварительно посчитать $|F|$ раз остаток от деления $n$ на каждое простое число.
При составлении множества запрещенных чисел на каждой итерации будет добавляться примерно $\frac{|F|}{p_i}$ чисел.
Таким образом, генерация множества запрещенных чисел имеет асимптотику $$O(|F|\sum_{p \in F}{\frac{1}{p}}) = O(|F|\ln{\ln p_{max}}),$$ где $p_{max}$ - максимальное
число из факторной базы. Если при этом вспомнить оценку числа простых чисел от 1 до p, то
$$|F| \approx \frac{p_{max}}{\ln p_{max}}.$$ Следовательно генерация множества запрещенных чисел имеет асимптотику 
$$O(\frac{p_{max}\ln{\ln p_{max}}}{\ln p_{max}}).$$
Этап построения $R_n$ имеет асимптотику $O(|F|\log_2{n})$, так как выполняется $|F|$ операций приведения по малому модулю.
Итого асиптотика равна $$O(\frac{p_{max}(\ln{\ln p_{max}} + \log_2{n})}{\ln p_{max}}).$$
\includegraphics[scale=0.6]{Series1.png}
\includegraphics[scale=0.8]{Series2.png}
\\
Таким образом можем заключить, что метод себя оправдывает при небольшой мощности фактор-множества.
В частности, при генерации простых чисел длины не более 32 бита, удалось добится прироста производительности в 1.5 раза при мощности фактор-множества, 
равной шести (соответствует пятерке на графике).
При этом в алгоритме Миллера-Рабина использованы базовые числа, которые позволяют точно проверять на простоту числа вплоть до 4759123141. 
Вполне возможно, что для генерации простых чисел большей длины понадобится фактор-множество большего размера, но это предмет следующих исследований.
