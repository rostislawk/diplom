\section{Оптимизация проверки простоты}
\subsection{Деление на малый разряд}
При пробных делениях на простые делитель много меньше основания системы счисления $b=2^{\omega}$. Этим можно воспользоваться и заменить
при вычислениях медленное деление разрядов на быстрое их умножение. Такая замена реализована в следующем алгоритме.
\begin{algorithm}[H]
\caption{ModDigit}
\textbf{Вход:}
$u=(u_{n-1}\ldots u_1 u_0)_b$~--- делимое, $m$~--- модуль, $0<m<\sqrt{b}$.

\textbf{Выход:}
$u_b \mod m$.

\textbf{Шаги:}
\begin{enumerate}
\item
$(r_1 r_0)_b\leftarrow 0$.

\item
$m^*\leftarrow b\mod m$.

\item
Для $i=n-1,\ldots,0$:
\begin{enumerate}
\item
$(r_1 r_0)_b\leftarrow (r_1 m^*+r_0)m^*+u_i$.
\end{enumerate}

\item
Пока $r_1\neq 0$:
\begin{enumerate}
\item
$(r_1 r_0)_b\leftarrow r_1 m^*+(r_{0_b}\mod m)$.
\end{enumerate}

\item
Возвратить $r_{0_b}\mod m$.
\end{enumerate}

\textbf{Корректность:}
На шагах алгоритма неявно вычисляется сумма
\begin{align*}
r&=u_{n-1}(m^*)^{n-1}+u_{n-2}(m^*)^{n-2}+\ldots+u_1 m^*+u_0\\
&=(\ldots(u_{n-1}m^*+u_{n-2})m^*+\ldots+u_1)m^*+u_0,
\end{align*}
которая сравнима с $u$ по модулю $m$.
Контролируется регистр $(r_1 r_0)_b$,
содержимое которого сравнимо с $r$ по модулю~$m$.

В регистр $(r_1 r_0)_b$ на шаге 3.1 помещается значение
$$
u_i+r_0 m^* + r_1 (m^*)^2\leq
(b-1)(1+(m-1)+(m-1)^2)=(b-1)(m^2-m+1)<b^2.
$$
Полученная оценка означает, что переполнение при записи не произойдет.

{\it Сложность}.
Требуется $2+d$ деления разрядов, $2n+d$ умножений
и столько же сложений.
Здесь $d$~--- число дополнительных итераций
на шаге~$4$.

Оценим $d$. По окончании первой дополнительной итерации
$$
(r_1 r_0)_b \leq (b-1)(m-1)+(m-1)=bm,
$$
а по окончании второй
$$
(r_1 r_0)_b \leq m(m-1)+(m-1)=m^2-1<b.
$$
Таким образом, $d\leq 2$.

Окончательно получаем:
$C_n({ModDigit})=4D+(2n+2)M+(2n+2)A$.
\end{algorithm}
Таким образом видим, что перед запуском более трудоемкого теста Рабина-Миллера или теста Ферма, можно предварительно проверить
делимость длинного числа на малые простые. С имеющимся у нас алгоритмом малые простые числа можно брать в диапазоне $[2...\sqrt{b}]$.
Известна оценка количества простых чисел от 1 до n: $\pi(x) \rightarrow \frac{x}{ln x}$. Понятно, что брать x, близкий к числу n невыгодно, так как
время работы алгоритма перебора будет экспоненциальным. Зато в диапазоне $[2...\sqrt{b}]$ можно сделать перебор по простым делителям. Если число
n делится хоть на одно из них, то n однозначно не является простым. 

\subsection{Деление на несколько малых разрядов}
Следующий алгоритм может использоваться для деления сразу на несколько малых простых.
\begin{algorithm}[H]
\caption{ModDigits}
\textbf{Вход:}
$u = (u_{n-1} ... u_0)_b$ - делимое, $m_1,...,m_s$ - взаимно простые модули, $\prod_{i=1}^sm_i < \sqrt{b}.$\\
\textbf{Выход:}
$(u~mod~m_1,...,u~mod~m_s).$\\
\textbf{Шаги:}

\begin{enumerate}
\item $m \leftarrow 1.$
\item Для $i = 1,...,s:$
\item ~~~~$m \leftarrow m\cdot m_i.$
\item $m\leftarrow ModDigit(u,m).$
\item Возвратить $(m~mod~m_1,...,m~mod~m_s).$
\end{enumerate}
{\it Сложность:} $C_n(ModDigit)+(s-1)M + sD = (4+s)D + (2n+4)(1M+1A) + (s-1)M.$
Для сравнения, расчет вычетов $u~mod~m_i$ по отдельности выполняется за время $4sD + s(2n+4)(1M+1A).$
\end{algorithm}
Имея этот алгоритм, можно несколько соптимизировать предварительное деление n на малые простые в диапазоне $[2...\sqrt{b}]$.
Числа из этого диапазона можно разбить на группы чисел$(p_{i_1}, p_{i_2}... p_{i_n})$, произведение которых меньше $\sqrt{b}$.
Тогда для этих групп можно провести алгоритм ModDigits. Задача состоит в оптимальности разбиения диапазона на группы. 
Отметим, что для всех простых битовой длины $\ln (\sqrt{b}) - 1$ нельзя подобрать такого малого простого, чтобы их можно было 
объединить в одну группу.Таких чисел примерно $ \frac{\sqrt{b}}{\ln(\sqrt{b})}~-~\frac{\sqrt{b}}{2(\ln(\sqrt{b}) - 1)}$, что довольно много.

\subsection{Тест Миллера-Рабина}

\begin{algorithm}[H]
\caption{Miller-Rabin}
\textbf{Вход:}
$n$ - число для проверки на простоту, $base$ - базовое множество, $r$ - количество раундов (мощность $base$).\\
\textbf{Выход:}
Ответ "составное" или "вероятно простое".\\
\textbf{Шаги:}
\begin{enumerate}
\item Представить $n - 1$ в виде $2^st, t$ - нечетно.
\item $r$ раундов:
\item ~~~~$a \leftarrow base[r]$
\item ~~~~$a \leftarrow a^t \mod n$
\item ~~~~Если $(x = 1 $или $x = n - 1)$
\item ~~~~~~~~$r \leftarrow r - 1$, перейти на шаг 2.
\item ~~~~Цикл $s - 1$ раз:
\item ~~~~~~~~$x \leftarrow x^2 \mod n $
\item ~~~~~~~~Если $(x = n - 1)$
\item ~~~~~~~~~~~~$r \leftarrow r - 1$, перейти на шаг 2.
\item ~~~~Вернуть "составное".
\item Вернуть "вероятно простое".
\end{enumerate} 
\textbf{Сложность:} $O(\log_2^3{n})$. 
В программе будет использовано базовое множество $base = \{2, 7, 61\}$, которое гарантирует безошибочность теста на числах до 4759123141.
\end{algorithm}